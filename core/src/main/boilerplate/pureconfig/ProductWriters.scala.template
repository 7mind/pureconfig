package pureconfig

import com.typesafe.config._

trait ProductWriters {
  // Special case because we don't want f to be B => Product1[A0].
  final def forProduct1[B, A0](keyA0: String)(f: B => A0)(implicit
    writerA0: ConfigWriter[A0]
  ): ConfigWriter[B] = new ConfigWriter[B] {
    def to(a: B): ConfigValue = {
      val values = f(a)
      val baseConf = ConfigFactory.empty()
      baseConf.withValue(keyA0, writerA0.to(values)).root()
    }
  }

  [2..22#final def forProduct1[B, [#A0#]]([#keyA0: String#])(f: B => Product1[[#A0#]])(implicit
    [#writerA0: ConfigWriter[A0]#]
  ): ConfigWriter[B] = new ConfigWriter[B] {
    def to(a: B): ConfigValue = {
      val values = f(a)
      val a##0Conf = ConfigFactory.empty()
      [#val a1Conf = writerA0 match {
        case w: WritesMissingKeys[A0 @unchecked] =>
          w.toOpt(values._1) match {
            case Some(v) =>
              a0Conf.withValue(keyA0, v)
            case None =>
              a0Conf
          }
        case _ =>
          a0Conf.withValue(keyA0, writerA0.to(values._1))
      }#
      ]
      a1Conf.root()
    }
  }#

  ]
}

object ProductWriters extends ProductWriters
