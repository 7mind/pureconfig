package pureconfig

import pureconfig.error._

trait ProductReaders {
  // Special case because f can't be curried.
  final def forProduct1[B, A0](keyA0: String)(f: A0 => B)(implicit
    readerA0: ConfigReader[A0]
  ): ConfigReader[B] = new ConfigReader[B] {
    def from(cur: ConfigCursor): Either[ConfigReaderFailures, B] =
      cur.asObjectCursor.right.flatMap { objCur =>
        val a0Result: Either[ConfigReaderFailures, A0 => B] = Right(f)
        val a1Result = ConvertHelpers.combineResults(a0Result, if (readerA0.isInstanceOf[ReadsMissingKeys]) readerA0.from(objCur.atKeyOrUndefined(keyA0)) else objCur.atKey(keyA0).right.flatMap(readerA0.from))(_(_))
        a1Result
      }
  }

  [2..22#final def forProduct1[B, [#A0#]]([#keyA0: String#])(f: ([#A0#]) => B)(implicit
    [#readerA0: ConfigReader[A0]#]
  ): ConfigReader[B] = new ConfigReader[B] {
    def from(cur: ConfigCursor): Either[ConfigReaderFailures, B] =
      cur.asObjectCursor.right.flatMap { objCur =>
        val a##0Result: Either[ConfigReaderFailures, [#A0# => ] => B] = Right(f.curried)
        [#val a1Result = ConvertHelpers.combineResults(a0Result, if (readerA0.isInstanceOf[ReadsMissingKeys]) readerA0.from(objCur.atKeyOrUndefined(keyA0)) else objCur.atKey(keyA0).right.flatMap(readerA0.from))(_(_))#
        ]
        a1Result
      }
  }#

  ]
}

object ProductReaders extends ProductReaders
